---
title: "Состояние промиса"
slug: "promise_state"
author: Сергей Железников
date: 24-11-2025
tags:
- async
- promises

---

# Состояния промиса и переход между ними

У промисов есть внутреннее **скрытое** состояние:
- pending
- fulfilled
- rejected 

## Как промис переходит между ними
Когда создается промис, он находится в состоянии `pending`
```js
const promise = new Promise((resolve, reject) => {/* ... */})
```
Далее внутри executor-функции происходит либо:
1. Вызов `resolve(value)`
- переводит промис из pending в fulfilled
- промис фиксируется с результатом `value`
- дальнейшие вызовы resolve и reject игнорируются
2. Вызов `reject(reason)`
- переводит промис из pending в rejected
- промис фиксируется с причиной ошибки `reson`
- дальнейшие вызовы resolve и reject игнорируются

После того, как промис перешел в одно из этих состояний, состояние больше не меняется. Это называется **settled**.

### Пример
```js
const promise = new Promise((resolve) => {
    resolve(42);
    console.log("still pending inside executor");
});

promise.then(console.log);
```

1. Создается промис с состоянием pending
2. Выполняется executor - функция и при вызове resolve(42) происходит переход в fulfilled, а значение результата
устанавливается в 42.
3. Выводится `still pending inside executor` потому, что это синхронный код.
4. Далее выполняется `.then`. Т.к. промис уже в состоянии fulfilled, то функция, переданная в then ставится в очередь микро-задач и выполнится, когда стек вызовов очистится.
В нашем случае, после выполнения п.3